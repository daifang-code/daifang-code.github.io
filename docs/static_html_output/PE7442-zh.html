<article class="bugdoc">
    <h2 class="bugdoc-title" id="Bug-Doc:BE7442">BE7442: 泛型参数和方法参数之间没有关系</h2>
    <h3>泛型参数和方法参数之间没有关系</h3>
    <section id="tip">
     <h4 style="border-top: 0pt; padding: 0pt 4pt 4pt 4pt;">缺陷信息</h4>
                <dl>
                    <dt>缺陷ID</dt>
                    <dd>BE7442</dd>
                    <dt>标签</dt>
                    <dd>JAVA ,FIND-BUGS</dd>
                    <dt>目录</dt>
                    <dd>Checkers/JAVA</dd>
                    <dt>作者</dt>
                    <dd>pinpoint</dd>
                </dl>
    <h4>缺陷描述</h4>
<p>泛型参数和方法参数之间没有关系</p>
<h4>漏洞与风险</h4>
<p>对泛型集合方法的这种调用包含一个与集合参数不兼容的类的参数（即，参数的类型既不是超类型也不是相应泛型参数的子类型）。
因此，集合不太可能包含与此处使用方法参数相等的任何对象。最可能的是，错误的值被传递给方法。通常，两个不相关的类的实例不相等。例如，如果Foo和Bar类与子类型无关，那么Foo的实例不应该等于Bar的实例。
在其它问题中，这样做可能会导致不对称的equals方法。</p>
<p>通常，两个不相关的类的实例不相等。例如，如果<code>Foo</code>和<code>Bar</code>类与子类型无关，那么<code>Foo</code>的实例不应该等于<code>Bar</code>的实例。在其它问题中，这样做可能会导致不对称的equals方法。例如，如果定义<code>Foo</code>类以使<code>Foo</code>等于<code>String</code>，则equals方法不对称，因为<code>String</code>只能等于<code>String</code>。</p>
<p>
在极少数情况下，人们确实定义了非对称的equals方法，并且仍然设法让他们的代码工作。虽然没有API记录或保证它，但通常情况下，如果您检查<code>Collection<String></code>包含一个<code>Foo</code>，那么参数的equals方法可以用于执行相等性检查（例如，<code>Foo</code>类的equals方法)。</p>
<h4>漏洞利用威胁</h4>
<p>中</p>

    </section>
</article>
